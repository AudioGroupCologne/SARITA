function [grid_pol, grid_cart] = getEigenmikeNodes(type, do_plot)
% Positons of Eigenmike microphones according to [1].
% 
% Parameters
% ----------
% type: string
%       'rad' or 'deg' [default: 'deg'] 
% do_plot: bool
%       [default: true]
%  
% Returns
% -------
% grid_pol: array
%       [32 X 3] array of spherical coordinates in radians or degrees with
%                azimuth 0..360 (counterclockwise),
%                elevation +90..-90 (top to bottom) and
%                radius in meters
% grid_cart: array
%       [32 X 3] array of corresponding cartesian coordinates in meters
%
% References
% ----------
% [1] mh acoustics LLC, Eigenmike User Manual,
%     Version 2 Rev. C, Appendix 4.5:
%     https://mhacoustics.com/sites/default/files/EigenStudio%20User%20Manual%20R02C.pdf
%
% (C) 12/2019 Tim Luebeck, Hannes Helmholz

    if nargin < 1, type = 'deg'; end
    if nargin < 2, do_plot = true; end
    
    if ~strcmpi(type, 'deg') && ~strcmpi(type, 'rad')
        error('Invalid polar coordinate type "%s", only "deg" or "rad" allowed.', type);
    end
    
    % radius provided in meters
    r_m = 0.042;
    
    % provided in azimuth and colatitude in degrees
    grid_pol_deg = [ ...
        0,   69; ...
        32,  90; ...
        0,   111; ...
        328, 90; ...
        0,   32; ...
        45,  55; ...
        69,  90; ...
        45,  125; ...
        0,   148; ...
        315, 125; ...
        291, 90; ...
        315, 55; ...
        91,  21; ...
        90,  58; ...
        90,  121; ...
        89,  159; ...
        180, 69; ...
        212, 90; ...
        180, 111; ...
        148, 90; ...
        180, 32; ...
        225, 55; ...
        249, 90; ...
        225, 125; ...
        180, 148; ...
        135, 125; ...
        111, 90; ...
        135, 55; ...
        269, 21; ...
        270, 58; ...
        270, 122; ...
        271, 159];
    
    % add radius provided in meters
    grid_pol_deg(:, 3) = r_m;
    
    % transform colatitude to elevation
    grid_pol_deg(:, 2) = 90 - grid_pol_deg(:, 2);
    
    % transform degrees to radians
    grid_pol_rad = (grid_pol_deg ./ 180) .* pi;

    grid_pol_rad(:, 3) = grid_pol_deg(:, 3);
    
    % transform spherical to cartesian
    [grid_cart(:, 1), grid_cart(:, 2), grid_cart(:, 3)] = sph2cart(...
        grid_pol_rad(:, 1), grid_pol_rad(:, 2), grid_pol_rad(:, 3));
    
    if do_plot
        figure();
        line(grid_cart(:, 1), grid_cart(:, 2), grid_cart(:, 3), ...
            'Color', 'b', 'LineStyle', ':', 'LineWidth', 1);
        text(grid_cart(:, 1), grid_cart(:, 2), grid_cart(:, 3), ...
            num2cell(1:size(grid_cart, 1)), ...
            'Color', 'b', 'FontSize', 12, 'FontWeight', 'Bold', ...
            'HorizontalAlignment', 'Center', 'VerticalAlignment', 'Middle');
        view(-69,14); % good viewing angle
        hold on; grid on; box on;
        quiver3(0,0,0,.3*r_m,0,0,'Color','r','LineWidth',1.5,'MaxHeadSize',1);
        quiver3(0,0,0,0,.3*r_m,0,'Color','g','LineWidth',1.5,'MaxHeadSize',1);
        quiver3(0,0,0,0,0,.3*r_m,'Color','b','LineWidth',1.5,'MaxHeadSize',1);
        axis equal; axis([-r_m, r_m, -r_m, r_m, -r_m, r_m]);
    end   
    
    % return
    if strcmpi(type,'deg')
        grid_pol = grid_pol_deg;
    else
        grid_pol = grid_pol_rad;
    end    
end
